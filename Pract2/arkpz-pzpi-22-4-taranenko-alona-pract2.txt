Харківський університет радіоелектроніки 
Факультет комп'ютерних наук 
Кафедра програмної інженерії 
 
 
 
ЗВІТ 
до практичної роботи номер 2 з дисципліни 
"Аналіз та рефакторинг коду" 
на тему: "Методи рефакторингу коду програмного забезпечення" 
 
 
 
Виконала ст. гр ПЗПІ-22-4 
Тараненко Альона Ігорівна 
 
Перевірив 
ст. викладач кафедри ПІ 
Сокорчук Ігор Петрович 
 
 
 
Харків 2024 
МЕТА 
Метою практичної роботи є формування навичок застосування методів рефакторингу коду для усунення проблем у програмному забезпеченні, покращення його структури та підвищення ефективності. Завдання спрямоване на освоєння принципів оптимізації коду, включаючи ідентифікацію проблемних місць, вибір відповідних методів рефакторингу та їх реалізацію для досягнення чистого, зрозумілого та підтримуваного програмного продукту.

ВСТУП 

 	Рефакторинг – це процес поліпшення внутрішньої структури програмного коду без змін його зовнішньої функціональності чи поведінки. Основна ідея полягає в тому, щоб зробити код більш зрозумілим, підтримуваним та зручним для розширення, при цьому зберігаючи його працездатність. Завдяки рефакторингу програмне забезпечення стає більш надійним та простішим у подальшій роботі. Рефакторинг стає необхідним у таких випадках: розширення функціоналу, коли додавання нових можливостей ускладнюється через неякісну структуру існуючого коду, виправлення помилок, які часто виникають через заплутану логіку або повторювані фрагменти коду, та оптимізація коду, навіть якщо програма працює коректно, адже її код завжди можна вдосконалити, щоб зробити його більш елегантним та зрозумілим. У рамках виконання практичної роботи для вдосконалення якості програмного коду було обрано три методи рефакторингу:
1.	Substitute Algorithm – для заміни неефективних алгоритмів більш простими та зрозумілими.
2.	Pull Up Method – для перенесення спільної логіки в суперклас.
3.	Hide Delegate – для спрощення доступу до залежностей та приховування деталей їх реалізації.



 	 






















МЕТОДИ РЕФАКТОРИНГУ КОДУ

1. Substitute Algorithm (Заміна алгоритму)
Опис: метод рефакторингу Substitute Algorithm полягає в заміні складного або неефективного алгоритму більш простим, зрозумілим і продуктивним. Це допомагає покращити читабельність і швидкість виконання коду, зменшити кількість помилок і спростити підтримку. Застосування цього методу особливо корисне, коли існуючий алгоритм складно зрозуміти або підтримувати.

Вирішувана проблема: складні або неефективні алгоритми ускладнюють розуміння та підтримку коду. Їх заміна на простіші алгоритми підвищує читабельність та якість.

Кроки рефакторингу:
1.	Аналіз існуючого алгоритму: визначте, чи є поточний алгоритм занадто складним, неефективним або важким для розуміння. Перевірте, чи виконує він необхідну функціональність і чи є повторювані або зайві операції.
2.	Пошук альтернативного рішення: знайдіть простіший і ефективніший алгоритм, який виконує ту саму функцію. Переконайтеся, що новий алгоритм враховує всі вимоги та крайні випадки.
3.	Тестування нового алгоритму: напишіть нову реалізацію в окремій функції або класі, не видаляючи стару. Перевірте новий алгоритм на основі існуючих тестових випадків.
4.	Порівняння результатів: порівняйте результати роботи старого і нового алгоритмів, щоб упевнитися в їх еквівалентності. Переконайтеся, що новий алгоритм виконується коректно у всіх сценаріях.
5.	Заміна старого алгоритму: замініть старий код новим алгоритмом. Переконайтеся, що у процесі заміни не було порушено залежностей у коді.
6.	Оптимізація і рефакторинг нового алгоритму: перегляньте новий код, щоб видалити зайві частини, спростити логіку або покращити стиль.
7.	Повторне тестування: виконайте всі необхідні модульні й інтеграційні тести, щоб упевнитися у правильності роботи нового алгоритму.
//Код до рефакторингу:

fun calculateDiscount(totalAmount: Int): Int {
    return if (totalAmount < 100) {
        (totalAmount * 0.05).toInt()
    } else if (totalAmount in 100..500) {
        (totalAmount * 0.10).toInt()
    } else {
        (totalAmount * 0.15).toInt()
    }
}
//Оптимізований код:

fun calculateDiscount(totalAmount: Int): Int {
    val discountRate = when {
        totalAmount < 100 -> 0.05
        totalAmount <= 500 -> 0.10
        else -> 0.15
    }
    return (totalAmount * discountRate).toInt()
}

Переваги рефакторингу:
-	Код став компактнішим та легшим для читання.
-	Зменшення повторення обчислень.
- Спрощення внесення змін.

2. Pull Up Method (Перенесення методу в суперклас)
Опис: Pull Up Method — це метод рефакторингу, який передбачає перенесення методу з декількох підкласів у суперклас. Він використовується, коли кілька підкласів мають однакові або схожі методи. Це дозволяє уникнути дублювання коду, зменшити складність і покращити структуру програми, роблячи її більш зрозумілою та легкою для підтримки.

Вирішувана проблема: однакова логіка в різних підкласах створює дублювання коду, що ускладнює підтримку та розвиток. Перенесення спільного методу в суперклас вирішує цю проблему.


Pull Up Method (Перенесення методу в суперклас)
Опис методу: Pull Up Method — це метод рефакторингу, який передбачає перенесення методу з декількох підкласів у суперклас. Він використовується, коли кілька підкласів мають однакові або схожі методи. Це дозволяє уникнути дублювання коду, зменшити складність і покращити структуру програми, роблячи її більш зрозумілою та легкою для підтримки.

Кроки рефакторингу:
1.	Виявлення дубльованих методів у підкласах: перегляньте підкласи та знайдіть методи, які мають однакову або подібну реалізацію. Якщо методи виконують ту саму функцію, але мають незначні відмінності, оцініть, чи можна уніфікувати їх у суперкласі.
2.	Аналіз суперкласу: переконайтеся, що суперклас є логічним місцем для цього методу. Суперклас має відображати загальну логіку для всіх підкласів, тому перенесення методу сюди має сенс.
3.	Уніфікація методів у підкласах (за потреби): якщо методи в підкласах мають незначні відмінності, створіть універсальну версію методу, яка враховує всі необхідні аспекти.
4.	Створення методу в суперкласі: перенесіть реалізацію методу в суперклас. Якщо метод залежить від специфічних властивостей підкласу, передбачте їхню генералізацію (наприклад, через параметри або абстрактні методи).
5.	Видалення методу з підкласів: після успішного перенесення методу видаліть його з усіх підкласів. Переконайтеся, що підкласи коректно використовують метод із суперкласу.
6.	Перевірка залежностей: переконайтеся, що метод у суперкласі не порушує залежності або логіку програми. Виправте всі посилання на старі методи у підкласах.
7.	Тестування: виконайте тестування програми, щоб перевірити, чи метод працює коректно після перенесення. Переконайтеся, що всі підкласи правильно успадковують поведінку методу.

//Код до рефакторингу:

open class Car {
    open fun getDetails(): String {
        return "Car details"
    }
}

class Sedan : Car() {
    override fun getDetails(): String {
        return "Sedan details"
    }
}

class SUV : Car() {
    override fun getDetails(): String {
        return "SUV details"
    }
}
//Оптимізований код:

open class Car {
    open fun getDetails(): String {
        return "${this::class.simpleName} details"
    }
}

class Sedan : Car()
class SUV : Car()

Переваги рефакторингу:
-	Спільна логіка перенесена в суперклас.
-	Підкласи стали легшими та менш залежними від дублікатів коду.
- Зменшення складності та покращення підтримуваності.

3. Hide Delegate (Сховати делегата)
Опис:
Метод Hide Delegate використовується для приховування деталей взаємодії з делегатом (об'єктом, до якого звертається клас). Клас, який використовує делегата, не повинен розкривати його методи чи структуру зовнішньому коду. Замість цього, доступ до делегата здійснюється через методи класу-клієнта. Це підвищує інкапсуляцію, спрощує взаємодію із класом і зменшує кількість залежностей між частинами програми.

Вирішувана проблема:
Прямий доступ до об'єктів через делегати може порушувати принцип інкапсуляції та ускладнювати код. Приховування делегата допомагає спростити роботу з такими об’єктами.

Кроки рефакторингу:
1.	Аналіз використання делегата: перегляньте, які методи делегата викликаються зовнішнім кодом через клас-клієнт. Визначте, чи дійсно клієнт повинен напряму знати про делегата або можна приховати ці взаємодії.
2.	Створення обгорткових методів у класі-клієнті: додайте в клас-клієнт методи, які виконують ті самі дії, що й виклики делегата. Методи класу-клієнта повинні інкапсулювати всі взаємодії з делегатом.
3.	Заміна викликів делегата: змініть код, який викликає методи делегата, на виклик методів класу-клієнта. Переконайтеся, що зовнішній код більше не звертається до делегата напряму.
4.	Перевірка залежностей: переконайтеся, що після рефакторингу клієнт-клас стає єдиною точкою доступу до делегата. Видаліть зайві імпорти чи залежності на делегат у зовнішньому коді.
5.	Тестування: перевірте функціональність, щоб упевнитися, що методи класу-клієнта правильно викликають делегат і зовнішній код працює без помилок.

//Код до рефакторингу:

class Order(var customer: Customer)

class Customer(val name: String)

fun main() {
    val order = Order(Customer("John Doe"))
    println(order.customer.name)
}
//Оптимізований код:

class Order(private val customer: Customer) {
    fun getCustomerName(): String {
        return customer.name
    }
}

class Customer(val name: String)

fun main() {
    val order = Order(Customer("John Doe"))
    println(order.getCustomerName())
}

Переваги рефакторингу:
-	Покращено інкапсуляцію даних.
-	Спрощено клієнтський код.
-	Зменшено залежність від деталей реалізації.




ІНСТРУМЕНТИ РЕФАКТОРИНГУ 


	 Інструменти, інтегровані в середовища розробки (IDE)
Сучасні IDE надають зручні вбудовані інструменти для автоматизації рефакторингу, які зменшують ризик помилок і спрощують роботу з кодом.
•	IntelliJ IDEA (Java, Kotlin):
Підтримує широкий набір функцій, таких як:
1.	Refactor This – універсальний інструмент для виклику доступних дій з рефакторингу.
2.	Extract Method/Class – виділення логіки у новий метод або клас для зменшення складності.
3.	Optimize Imports – автоматичне очищення невикористаних залежностей.
•	Visual Studio (C#, .NET):
Середовище надає потужні інструменти для рефакторингу, включаючи:
1.	Quick Actions – автоматичні пропозиції оптимізації коду.
2.	Encapsulate Field – створення властивостей замість публічних полів.
3.	Remove Unused References – видалення непотрібних бібліотек для оптимізації проєкту.
•	PyCharm (Python):
Популярне середовище для Python включає:
1.	Rename – безпечне перейменування змінних, класів чи методів.
2.	Inline Method/Variable – видалення зайвих змінних або методів з інтеграцією логіки в код.

Статичні аналізатори коду
Статичні аналізатори автоматично виявляють недоліки в структурі коду, дублювання, помилки та пропонують оптимізації.
•	SonarLint:
o	Інтеграція з IDE для виявлення проблем у реальному часі.
o	Надає рекомендації щодо усунення технічного боргу.
•	ReSharper (JetBrains для Visual Studio):
o	Convert to LINQ – автоматизація роботи з колекціями.
o	Extract Interface – поліпшення дизайну класів через створення інтерфейсів.
•	Codacy:
o	Хмарний аналізатор коду для більш ніж 40 мов.
o	Допомагає з ідентифікацією стилістичних проблем та помилок.

Інструменти форматування та оптимізації
Ці інструменти забезпечують єдиний стиль програмування та спрощують читабельність коду.
•	Prettier (JavaScript, HTML, CSS):
o	Форматує код, забезпечуючи його консистентність.
o	Усуває стилістичні помилки.
•	Black (Python):
o	Автоматичне форматування Python-коду згідно з PEP8.
o	Полегшує підтримку та аналіз коду.
•	Clang-Tidy (C++):
o	Аналізує код для виявлення застарілих конструкцій.
o	Пропонує оптимізацію циклів та структур.

Інструменти для командного рефакторингу
У великих проєктах важливо забезпечити командний підхід до рефакторингу для підтримання єдиної структури коду.
•	SonarQube:
o	Виконує повний аналіз репозиторію для виявлення технічного боргу та дублікатів.
o	Інтегрується з Git для автоматичного контролю якості.
•	GitHub Copilot:
o	Генерує оптимізований код на основі машинного навчання.
o	Пропонує покращення під час розробки.
•	Refactoring.Guru Plugins:
o	Надає набір розширень для виконання стандартних технік рефакторингу.
o	Особливо зручні для використання в командній роботі.











ВИСНОВКИ 
 	 
У ході виконання практичної роботи було розглянуто концепцію рефакторингу коду як важливого етапу розробки програмного забезпечення, спрямованого на покращення його внутрішньої структури без зміни зовнішньої функціональності. Було детально вивчено методи рефакторингу, такі як Substitute Algorithm, Pull Up Method та Hide Delegate, які дозволяють усунути поширені проблеми у коді, зменшити дублювання, підвищити читабельність та підтримуваність.

Практичне застосування методів на реальних прикладах коду продемонструвало їх ефективність у вирішенні типових проблем, зокрема складності алгоритмів, дублювання логіки в підкласах та надмірного використання делегатів. В результаті рефакторингу код став більш зрозумілим, структурованим і легким у підтримці, що значно спрощує його подальший розвиток і масштабування.

Додатково було досліджено інструменти для рефакторингу, які інтегровані в сучасні середовища розробки, такі як IntelliJ IDEA, Visual Studio, PyCharm, а також статичні аналізатори коду, зокрема SonarLint, ReSharper та Codacy. Ці інструменти спрощують виконання рефакторингу, забезпечують швидкий аналіз коду та автоматизують рутинні завдання, знижуючи ризик людських помилок.

Під час роботи також було проаналізовано значення форматування та стандартизації коду. Використання таких інструментів, як Prettier, Black і Clang-Tidy, сприяло дотриманню єдиного стилю написання коду та підвищило його загальну якість.

Загалом виконання роботи показало, що рефакторинг є необхідним етапом у життєвому циклі програмного забезпечення. Він не лише покращує якість коду, але й створює основу для його стабільного функціонування в довгостроковій перспективі. Рефакторинг сприяє підвищенню ефективності командної роботи, дозволяючи розробникам краще розуміти структуру програми, а також мінімізує ризики, пов’язані з технічним боргом. Застосування отриманих знань на практиці дозволить ефективно вирішувати завдання з оптимізації коду в майбутніх проєктах.




























ДОДАТОК А
Список використаних джерел

1. Martin Fowler. Refactoring. Improving the Design of Existing Code– AddisonWesley Professional, 1999. – 464 p



















ДОДАТОК Б
Відео на YouTube

URL: https://youtu.be/tabbBysyoJk

















ДОДАТОК В 
Презентація 
 


















